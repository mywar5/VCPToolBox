// Plugin/LightMemoPlugin/LightMemo.js
const fs = require('fs').promises;
const path = require('path');
const axios = require('axios');
const dotenv = require('dotenv');
const { Jieba } = require('@node-rs/jieba');
const { dict } = require('@node-rs/jieba/dict');

class BM25Ranker {
    constructor() {
        this.k1 = 1.5;  // ËØçÈ¢ëÈ•±ÂíåÂèÇÊï∞
        this.b = 0.75;  // ÈïøÂ∫¶ÊÉ©ÁΩöÂèÇÊï∞
    }

    /**
     * ËÆ°ÁÆóBM25ÂàÜÊï∞
     * @param {Array} queryTokens - Êü•ËØ¢ÂàÜËØç
     * @param {Array} docTokens - ÊñáÊ°£ÂàÜËØç
     * @param {Number} avgDocLength - Âπ≥ÂùáÊñáÊ°£ÈïøÂ∫¶
     * @param {Object} idfScores - ÊØè‰∏™ËØçÁöÑIDFÂàÜÊï∞
     */
    score(queryTokens, docTokens, avgDocLength, idfScores) {
        const docLength = docTokens.length;
        const termFreq = {};
        
        // ÁªüËÆ°ËØçÈ¢ë
        for (const token of docTokens) {
            termFreq[token] = (termFreq[token] || 0) + 1;
        }

        let score = 0;
        for (const token of queryTokens) {
            const tf = termFreq[token] || 0;
            if (tf === 0) continue;

            const idf = idfScores[token] || 0;
            
            // BM25ÂÖ¨Âºè
            const numerator = tf * (this.k1 + 1);
            const denominator = tf + this.k1 * (1 - this.b + this.b * (docLength / avgDocLength));
            
            score += idf * (numerator / denominator);
        }

        return score;
    }

    /**
     * ËÆ°ÁÆóIDFÔºàÈÄÜÊñáÊ°£È¢ëÁéáÔºâ
     * @param {Array} allDocs - ÊâÄÊúâÊñáÊ°£ÁöÑÂàÜËØçÊï∞ÁªÑ
     */
    calculateIDF(allDocs) {
        const N = allDocs.length;
        const df = {}; // document frequency

        // ÁªüËÆ°ÊØè‰∏™ËØçÂá∫Áé∞Âú®Â§öÂ∞ëÊñáÊ°£‰∏≠
        for (const doc of allDocs) {
            const uniqueTokens = new Set(doc);
            for (const token of uniqueTokens) {
                df[token] = (df[token] || 0) + 1;
            }
        }

        // ËÆ°ÁÆóIDF
        const idfScores = {};
        for (const token in df) {
            // IDF = log((N - df + 0.5) / (df + 0.5) + 1)
            idfScores[token] = Math.log((N - df[token] + 0.5) / (df[token] + 0.5) + 1);
        }

        return idfScores;
    }
}

class LightMemoPlugin {
    constructor() {
        this.name = 'LightMemo';
        this.vectorDBManager = null;
        this.getSingleEmbedding = null;
        this.projectBasePath = '';
        this.dailyNoteRootPath = '';
        this.rerankConfig = {};
        this.excludedFolders = [];
        this.semanticGroups = null;
        this.wordToGroupMap = new Map();
        this.stopWords = new Set([
            'ÁöÑ', '‰∫Ü', 'Âú®', 'ÊòØ', 'Êàë', '‰Ω†', '‰ªñ', 'Â•π', 'ÂÆÉ',
            'Ëøô', 'ÈÇ£', 'Êúâ', '‰∏™', 'Â∞±', '‰∏ç', '‰∫∫', 'ÈÉΩ', '‰∏Ä',
            '‰∏ä', '‰πü', 'Âæà', 'Âà∞', 'ËØ¥', 'Ë¶Å', 'Âéª', 'ËÉΩ', '‰ºö'
        ]);
        
        // ‚úÖ ÂàùÂßãÂåñ jieba ÂÆû‰æãÔºàÂä†ËΩΩÈªòËÆ§Â≠óÂÖ∏Ôºâ
        try {
            this.jiebaInstance = Jieba.withDict(dict);
            console.log('[LightMemo] Jieba initialized successfully.');
        } catch (error) {
            console.error('[LightMemo] Failed to initialize Jieba:', error);
            this.jiebaInstance = null;
        }
    }

    initialize(config, dependencies) {
        this.projectBasePath = config.PROJECT_BASE_PATH || path.join(__dirname, '..', '..');
        this.dailyNoteRootPath = path.join(this.projectBasePath, 'dailynote');
        
        if (dependencies.vectorDBManager) {
            this.vectorDBManager = dependencies.vectorDBManager;
        }
        if (dependencies.getSingleEmbedding) {
            this.getSingleEmbedding = dependencies.getSingleEmbedding;
        }

        this.loadConfig(); // Load config after dependencies are set
        this.loadSemanticGroups();
        console.log('[LightMemo] Plugin initialized successfully as a hybrid service.');
    }

    loadConfig() {
        // config.env is already loaded by Plugin.js, we just need to read the values
        const excluded = process.env.EXCLUDED_FOLDERS || "Â∑≤Êï¥ÁêÜ,Â§ú‰ºΩ,MusicDiary";
        this.excludedFolders = excluded.split(',').map(f => f.trim()).filter(Boolean);

        this.rerankConfig = {
            url: process.env.RerankUrl || '',
            apiKey: process.env.RerankApi || '',
            model: process.env.RerankModel || '',
            maxTokens: parseInt(process.env.RerankMaxTokensPerBatch) || 30000,
            multiplier: 2.0
        };
    }

    async processToolCall(args) {
        try {
            return await this.handleSearch(args);
        } catch (error) {
            console.error('[LightMemo] Error processing tool call:', error);
            // Return an error structure that Plugin.js can understand
            return { plugin_error: error.message || 'An unknown error occurred in LightMemo.' };
        }
    }

    async handleSearch(args) {
        const { query, maid, k = 5, rerank = false, search_all_knowledge_bases = false } = args;

        if (!query || !maid) {
            throw new Error("ÂèÇÊï∞ 'query' Âíå 'maid' ÊòØÂøÖÈúÄÁöÑ„ÄÇ");
        }

        // --- Á¨¨‰∏ÄÈò∂ÊÆµÔºöÂÖ≥ÈîÆËØçÂàùÁ≠õÔºàBM25Ôºâ ---
        const queryTokens = this._tokenize(query);
        console.log(`[LightMemo] Query tokens: [${queryTokens.join(', ')}]`);

        // Êâ©Â±ïÊü•ËØ¢ËØçÔºàËØ≠‰πâÁªÑÔºâ
        const expandedTokens = this._expandQueryTokens(queryTokens);
        const allQueryTokens = [...new Set([...queryTokens, ...expandedTokens])];
        console.log(`[LightMemo] Expanded tokens: [${allQueryTokens.join(', ')}]`);

        // ‰ªéÊâÄÊúâÊó•ËÆ∞Êú¨‰∏≠Êî∂ÈõÜÂÄôÈÄâchunks
        const candidates = await this._gatherCandidateChunks(maid, search_all_knowledge_bases);
        
        if (candidates.length === 0) {
            return `Ê≤°ÊúâÊâæÂà∞ÁΩ≤Âêç‰∏∫ "${maid}" ÁöÑÁõ∏ÂÖ≥ËÆ∞ÂøÜ„ÄÇ`;
        }

        console.log(`[LightMemo] Gathered ${candidates.length} candidate chunks from ${new Set(candidates.map(c => c.dbName)).size} diaries.`);

        // BM25ÊéíÂ∫è
        const bm25Ranker = new BM25Ranker();
        const allDocs = candidates.map(c => c.tokens);
        const idfScores = bm25Ranker.calculateIDF(allDocs);
        const avgDocLength = allDocs.reduce((sum, doc) => sum + doc.length, 0) / allDocs.length;

        const scoredCandidates = candidates.map(candidate => {
            const bm25Score = bm25Ranker.score(
                allQueryTokens,
                candidate.tokens,
                avgDocLength,
                idfScores
            );
            return { ...candidate, bm25Score };
        });

        // Âèñtop K*3Áî®‰∫éÂêëÈáèÊ£ÄÁ¥¢
        const topByKeyword = scoredCandidates
            .filter(c => c.bm25Score > 0)  // ÂøÖÈ°ªÊúâÂÖ≥ÈîÆËØçÂåπÈÖç
            .sort((a, b) => b.bm25Score - a.bm25Score)
            .slice(0, k * 3);

        if (topByKeyword.length === 0) {
            return `ÂÖ≥‰∫é"${query}"ÔºåÊ≤°ÊúâÊâæÂà∞ÂåÖÂê´Áõ∏ÂÖ≥ÂÖ≥ÈîÆËØçÁöÑËÆ∞ÂøÜÁâáÊÆµ„ÄÇ`;
        }

        console.log(`[LightMemo] BM25 filtered to ${topByKeyword.length} chunks.`);

        // --- Á¨¨‰∫åÈò∂ÊÆµÔºöÂêëÈáèÁ≤æÊéí ---
        const queryVector = await this.getSingleEmbedding(query);
        if (!queryVector) {
            throw new Error("Êü•ËØ¢ÂÜÖÂÆπÂêëÈáèÂåñÂ§±Ë¥•„ÄÇ");
        }

        // ‰∏∫ÊØè‰∏™ÂÄôÈÄâchunkËÆ°ÁÆóÂêëÈáèÁõ∏‰ººÂ∫¶
        const vectorScoredCandidates = await this._scoreByVectorSimilarity(
            topByKeyword,
            queryVector
        );

        // Ê∑∑ÂêàBM25ÂíåÂêëÈáèÂàÜÊï∞
        const hybridScored = vectorScoredCandidates.map(c => ({
            ...c,
            hybridScore: c.bm25Score * 0.6 + c.vectorScore * 0.4  // ÊèêÈ´òÂÖ≥ÈîÆËØçÊùÉÈáç
        })).sort((a, b) => b.hybridScore - a.hybridScore);

        // Âèñtop K
        let finalResults = hybridScored.slice(0, k);

        // --- Á¨¨‰∏âÈò∂ÊÆµÔºöRerankÔºàÂèØÈÄâÔºâ ---
        if (rerank && finalResults.length > 0) {
            finalResults = await this._rerankDocuments(query, finalResults, k);
        }

        return this.formatResults(finalResults, query);
    }

    formatResults(results, query) {
        if (results.length === 0) {
            return `ÂÖ≥‰∫é"${query}"ÔºåÂú®ÊåáÂÆöÁöÑÁü•ËØÜÂ∫ì‰∏≠Ê≤°ÊúâÊâæÂà∞Áõ∏ÂÖ≥ÁöÑËÆ∞ÂøÜÁâáÊÆµ„ÄÇ`;
        }

        const searchedDiaries = [...new Set(results.map(r => r.dbName))];
        let content = `\n[--- LightMemo ËΩªÈáèÂõûÂøÜ ---]\n`;
        content += `[Êü•ËØ¢ÂÜÖÂÆπ: "${query}"]\n`;
        content += `[ÊêúÁ¥¢ËåÉÂõ¥: ${searchedDiaries.join(', ')}]\n\n`;
        content += `[ÊâæÂà∞ ${results.length} Êù°Áõ∏ÂÖ≥ËÆ∞ÂøÜÁâáÊÆµ:]\n`;

        results.forEach((r, index) => {
            // üëá ‰øÆÂ§çÔºöÊ≠£Á°ÆËé∑ÂèñÂàÜÊï∞
            let scoreValue = 0;
            let scoreType = '';
            
            if (typeof r.rerank_score === 'number' && !isNaN(r.rerank_score)) {
                scoreValue = r.rerank_score;
                scoreType = r.rerank_failed ? 'Ê∑∑Âêà' : 'Rerank';
            } else if (typeof r.hybridScore === 'number' && !isNaN(r.hybridScore)) {
                scoreValue = r.hybridScore;
                scoreType = 'Ê∑∑Âêà';
            } else if (typeof r.vectorScore === 'number' && !isNaN(r.vectorScore)) {
                scoreValue = r.vectorScore;
                scoreType = 'ÂêëÈáè';
            } else if (typeof r.bm25Score === 'number' && !isNaN(r.bm25Score)) {
                scoreValue = r.bm25Score;
                scoreType = 'BM25';
            }
            
            const scoreDisplay = scoreValue > 0
                ? `${(scoreValue * 100).toFixed(1)}%(${scoreType})`
                : 'N/A';
            
            content += `--- (Êù•Ê∫ê: ${r.dbName}, Áõ∏ÂÖ≥ÊÄß: ${scoreDisplay})\n`;
            content += `${r.text.trim()}\n`;
        });

        content += `\n[--- ÂõûÂøÜÁªìÊùü ---]\n`;
        return content;
    }

    _estimateTokens(text) {
        if (!text) return 0;
        const chineseChars = (text.match(/[\u4e00-\u9fa5]/g) || []).length;
        const otherChars = text.length - chineseChars;
        return Math.ceil(chineseChars * 1.5 + otherChars * 0.25);
    }

    async _rerankDocuments(query, documents, originalK) {
        if (!this.rerankConfig.url || !this.rerankConfig.apiKey || !this.rerankConfig.model) {
            console.warn('[LightMemo] Rerank not configured. Skipping.');
            return documents.slice(0, originalK);
        }
        console.log(`[LightMemo] Starting rerank for ${documents.length} documents.`);

        const rerankUrl = new URL('v1/rerank', this.rerankConfig.url).toString();
        const headers = {
            'Authorization': `Bearer ${this.rerankConfig.apiKey}`,
            'Content-Type': 'application/json',
        };
        const maxTokens = this.rerankConfig.maxTokens;
        const queryTokens = this._estimateTokens(query);

        let batches = [];
        let currentBatch = [];
        let currentTokens = queryTokens;

        for (const doc of documents) {
            const docTokens = this._estimateTokens(doc.text);
            if (currentTokens + docTokens > maxTokens && currentBatch.length > 0) {
                batches.push(currentBatch);
                currentBatch = [doc];
                currentTokens = queryTokens + docTokens;
            } else {
                currentBatch.push(doc);
                currentTokens += docTokens;
            }
        }
        if (currentBatch.length > 0) {
            batches.push(currentBatch);
        }

        console.log(`[LightMemo] Split into ${batches.length} batches for reranking.`);

        let allRerankedDocs = [];
        for (let i = 0; i < batches.length; i++) {
            const batch = batches[i];
            const docTexts = batch.map(d => d.text);
            
            try {
                const body = {
                    model: this.rerankConfig.model,
                    query: query,
                    documents: docTexts,
                    top_n: docTexts.length
                };

                console.log(`[LightMemo] Reranking batch ${i + 1}/${batches.length} (${docTexts.length} docs).`);
                const response = await axios.post(rerankUrl, body, {
                    headers,
                    timeout: 30000  // üëà Ê∑ªÂä†Ë∂ÖÊó∂
                });

                let responseData = response.data;
                if (typeof responseData === 'string') {
                    try {
                        responseData = JSON.parse(responseData);
                    } catch (e) {
                        console.error('[LightMemo] Failed to parse rerank response:', responseData);
                        throw new Error('Invalid JSON response');
                    }
                }

                if (responseData && Array.isArray(responseData.results)) {
                    const rerankedResults = responseData.results;
                    console.log(`[LightMemo] Batch ${i + 1} rerank scores:`,
                        rerankedResults.map(r => r.relevance_score.toFixed(3)).join(', '));
                    
                    const orderedBatch = rerankedResults
                        .map(result => {
                            const originalDoc = batch[result.index];
                            if (!originalDoc) return null;
                            return {
                                ...originalDoc,
                                rerank_score: result.relevance_score
                            };
                        })
                        .filter(Boolean);
                    
                    allRerankedDocs.push(...orderedBatch);
                } else {
                    throw new Error('Invalid response format');
                }
            } catch (error) {
                console.error(`[LightMemo] Rerank failed for batch ${i + 1}:`, error.message);
                if (error.response) {
                    console.error(`[LightMemo] API Error - Status: ${error.response.status}, Data:`,
                        JSON.stringify(error.response.data).slice(0, 200));
                }
                
                // ‚ö†Ô∏è ÂÖ≥ÈîÆ‰øÆÂ§çÔºö‰øùÁïôÂéüÊúâÂàÜÊï∞
                const fallbackBatch = batch.map(doc => ({
                    ...doc,
                    rerank_score: doc.hybridScore || doc.vectorScore || doc.bm25Score || 0,
                    rerank_failed: true  // Ê†áËÆ∞rerankÂ§±Ë¥•
                }));
                allRerankedDocs.push(...fallbackBatch);
            }
        }

        // üëá ‰øÆÂ§çÔºöÂÆâÂÖ®ÊéíÂ∫è
        allRerankedDocs.sort((a, b) => {
            const scoreA = a.rerank_score ?? 0;
            const scoreB = b.rerank_score ?? 0;
            return scoreB - scoreA;
        });

        const finalDocs = allRerankedDocs.slice(0, originalK);
        console.log(`[LightMemo] Rerank complete. Final scores:`,
            finalDocs.map(d => (d.rerank_score || 0).toFixed(3)).join(', '));
        
        return finalDocs;
    }

    /**
     * ÊîπÁî®jiebaÂàÜËØçÔºà‰øùÁïôËØçÁªÑÔºâ
     */

 /* ‰ΩøÁî® jieba ÂàÜËØçÔºà‰øùÁïôËØçÁªÑÔºâ
 */
_tokenize(text) {
    if (!text) return [];
    
    // ‚úÖ ‰ΩøÁî®ÂÆû‰æãË∞ÉÁî® cut ÊñπÊ≥ï
    // ÂèÇÊï∞ËØ¥ÊòéÔºö
    // - text: Ë¶ÅÂàÜËØçÁöÑÊñáÊú¨
    // - false: ‰∏ç‰ΩøÁî® HMMÔºàÈöêËóèÈ©¨Â∞îÂèØÂ§´Ê®°ÂûãÔºâÔºå‰ΩøÁî®Á≤æÁ°ÆÊ®°Âºè
    if (!this.jiebaInstance) {
        console.warn('[LightMemo] Jieba not initialized, falling back to simple split.');
        // ÈôçÁ∫ßÊñπÊ°àÔºöÁÆÄÂçïÂàÜËØç
        return text.split(/\s+/)
            .map(w => w.toLowerCase().trim())
            .filter(w => w.length >= 2)
            .filter(w => !this.stopWords.has(w));
    }
    
    const words = this.jiebaInstance.cut(text, false);  // Á≤æÁ°ÆÊ®°Âºè
    
    return words
        .map(w => w.toLowerCase().trim())
        .filter(w => w.length >= 2)
        .filter(w => !this.stopWords.has(w))
        .filter(w => w.length > 0);
}
    /**
     * ‰ªéÊâÄÊúâÁõ∏ÂÖ≥Êó•ËÆ∞Êú¨‰∏≠Êî∂ÈõÜchunksÔºàÂ∏¶ÁΩ≤ÂêçËøáÊª§Ôºâ
     */
    async _gatherCandidateChunks(maid, searchAll) {
        let allDiaries = [];
        try {
            allDiaries = await fs.readdir(this.dailyNoteRootPath, { withFileTypes: true });
        } catch (error) {
            console.error('[LightMemo] Failed to read diary root:', error);
            return [];
        }

        const availableDiaries = allDiaries
            .filter(dirent => dirent.isDirectory())
            .map(dirent => dirent.name)
            .filter(name => {
                if (name.startsWith('Â∑≤Êï¥ÁêÜ') || name.endsWith('Á∞á')) return false;
                if (this.excludedFolders.includes(name)) return false;
                return true;
            });

        // Â¶ÇÊûú‰∏çÊòØÊêúÁ¥¢ÂÖ®ÈÉ®ÔºåÂè™ÊêúÂåÖÂê´maidÂêçÂ≠óÁöÑÊó•ËÆ∞Êú¨
        const targetDiaries = searchAll
            ? availableDiaries
            : availableDiaries.filter(name => name.includes(maid));

        const candidates = [];

        for (const diaryName of targetDiaries) {
            // ‰ªéVectorDBManagerËé∑ÂèñËøô‰∏™Êó•ËÆ∞Êú¨ÁöÑchunkMap
            if (!this.vectorDBManager.chunkMaps.has(diaryName)) {
                // Â∞ùËØïÂä†ËΩΩÁ¥¢Âºï
                await this.vectorDBManager.loadIndexForSearch(diaryName);
            }

            const chunkMap = this.vectorDBManager.chunkMaps.get(diaryName);
            if (!chunkMap) continue;

            // ÈÅçÂéÜÊâÄÊúâchunks
            for (const [label, data] of Object.entries(chunkMap)) {
                const text = data.text || '';
                
                // ÁΩ≤ÂêçËøáÊª§ÔºöÊ£ÄÊü•chunkÂÜÖÂÆπÊòØÂê¶ÂåÖÂê´ÁΩ≤Âêç
                if (!searchAll && !this._checkSignature(text, maid)) {
                    continue;  // Ë∑≥Ëøá‰∏çÂ±û‰∫éËøô‰∏™agentÁöÑchunk
                }

                // ÂàÜËØç
                const tokens = this._tokenize(text);
                
                candidates.push({
                    dbName: diaryName,
                    label: parseInt(label),
                    text: text,
                    tokens: tokens,
                    sourceFile: data.sourceFile
                });
            }
        }

        return candidates;
    }

    /**
     * Ê£ÄÊü•ÊñáÊú¨‰∏≠ÊòØÂê¶ÂåÖÂê´ÁâπÂÆöÁΩ≤Âêç
     */
    _checkSignature(text, maid) {
        if (!text || !maid) return false;
        
        // ÊèêÂèñÁ¨¨‰∏ÄË°å
        const firstLine = text.split('\n')[0].trim();
        
        // Ê£ÄÊü•Á¨¨‰∏ÄË°åÊòØÂê¶ÂåÖÂê´ÁΩ≤Âêç
        return firstLine.includes(maid);
    }

    /**
     * ‰∏∫ÂÄôÈÄâchunksËÆ°ÁÆóÂêëÈáèÁõ∏‰ººÂ∫¶
     */
    async _scoreByVectorSimilarity(candidates, queryVector) {
        const scored = [];

        for (const candidate of candidates) {
            // ‰ªéVectorDBManagerËé∑ÂèñËøô‰∏™chunkÁöÑÂêëÈáè
            const index = this.vectorDBManager.indices.get(candidate.dbName);
            if (!index) continue;

            try {
                const chunkVector = index.getPoint(candidate.label);
                const similarity = this._cosineSimilarity(queryVector, chunkVector);
                
                scored.push({
                    ...candidate,
                    vectorScore: similarity
                });
            } catch (error) {
                // chunkÂèØËÉΩÂ∑≤Ë¢´Âà†Èô§ÔºåË∑≥Ëøá
                continue;
            }
        }

        return scored;
    }

    _cosineSimilarity(vecA, vecB) {
        if (!vecA || !vecB || vecA.length !== vecB.length) {
            return 0;
        }
        let dotProduct = 0;
        let normA = 0;
        let normB = 0;
        for (let i = 0; i < vecA.length; i++) {
            dotProduct += vecA[i] * vecB[i];
            normA += vecA[i] * vecA[i];
            normB += vecB[i] * vecB[i];
        }
        if (normA === 0 || normB === 0) {
            return 0;
        }
        return dotProduct / (Math.sqrt(normA) * Math.sqrt(normB));
    }

    /**
     * Âü∫‰∫éËØ≠‰πâÁªÑÊâ©Â±ïÊü•ËØ¢ËØç
     */
    _expandQueryTokens(queryTokens) {
        if (this.wordToGroupMap.size === 0) {
            return [];
        }

        const expandedTokens = new Set();
        const activatedGroups = new Set();

        for (const token of queryTokens) {
            const groupWords = this.wordToGroupMap.get(token.toLowerCase());
            if (groupWords) {
                const groupKey = groupWords.join(',');
                if (!activatedGroups.has(groupKey)) {
                    activatedGroups.add(groupKey);
                    groupWords.forEach(word => {
                        if (!queryTokens.includes(word)) {
                            expandedTokens.add(word);
                        }
                    });
                }
            }
        }

        return Array.from(expandedTokens);
    }

    async loadSemanticGroups() {
        const semanticGroupsPath = path.join(this.projectBasePath, 'Plugin', 'RAGDiaryPlugin', 'semantic_groups.json');
        try {
            const data = await fs.readFile(semanticGroupsPath, 'utf-8');
            this.semanticGroups = JSON.parse(data);
            this.wordToGroupMap = new Map();
            if (this.semanticGroups && this.semanticGroups.groups) {
                for (const groupName in this.semanticGroups.groups) {
                    const group = this.semanticGroups.groups[groupName];
                    if (group.words && Array.isArray(group.words)) {
                        const lowercasedWords = group.words.map(w => w.toLowerCase());
                        for (const word of lowercasedWords) {
                            this.wordToGroupMap.set(word, lowercasedWords);
                        }
                    }
                }
            }
            console.log(`[LightMemo] Semantic groups loaded successfully. ${this.wordToGroupMap.size} words mapped.`);
        } catch (error) {
            console.warn('[LightMemo] Could not load semantic_groups.json. Proceeding without query expansion.', error.message);
            this.semanticGroups = null;
            this.wordToGroupMap = new Map();
        }
    }
}

module.exports = new LightMemoPlugin();
